# This software and any associated files are copyright 2010 Brian Carver and
# Michael Lissner.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  Under Sections 7(a) and 7(b) of version 3 of the GNU Affero General Public
#  License, that license is supplemented by the following terms:
#
#  a) You are required to preserve this legal notice and all author
#  attributions in this program and its accompanying documentation.
#
#  b) You are prohibited from misrepresenting the origin of any material
#  within this covered work and you are required to mark in reasonable
#  ways how any modified versions differ from the original version.

import sys
sys.path.append('/var/www/court-listener/alert')

from alert import settings
from django.core.management import setup_environ
setup_environ(settings)

from alert.lib.string_utils import clean_string
from alert.lib.string_utils import harmonize
from alert.lib.string_utils import titlecase
from alert.lib.string_utils import trunc
from alert.search.models import Citation
from alert.search.models import Document
from alert.search.tasks import save_doc_handler
from alert.scrapers.models import urlToHash


from django.db.models.signals import post_save
from django.utils.encoding import smart_unicode

# adding alert to the front of this breaks celery. Ignore pylint error.
from scrapers.tasks import extract_doc_content

import hashlib
import httplib
import logging.handlers
import StringIO
import time
import traceback
import urllib2

LOG_FILENAME = '/var/log/scraper/daemon_log.out'

# Set up a specific logger with our desired output level
logger = logging.getLogger('Logger')
logger.setLevel(logging.DEBUG)

# Add the log message handler to the logger
handler = logging.handlers.RotatingFileHandler(
              LOG_FILENAME, maxBytes=5120000, backupCount=1)

logger.addHandler(handler)


class makeDocError(Exception):
    '''
    This is a simple class for errors stemming from the makeDocFromURL function.
    It doesn't do much except to make the code a little cleaner and more precise.
    '''
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)


def readURL(url, courtID):
    try:
        html = urllib2.urlopen(url).read()
    except urllib2.HTTPError, e:
        print "****ERROR CONNECTING TO COURT: " + str(courtID) + "****"
        print 'HTTPError = ' + str(e.code)
    except urllib2.URLError, e:
        print "****ERROR CONNECTING TO COURT: " + str(courtID) + "****"
        print 'URLError = ' + str(e.reason)
    except httplib.HTTPException, e:
        print "****ERROR CONNECTING TO COURT: " + str(courtID) + "****"
        print 'HTTPException'
    except Exception:
        print "****ERROR CONNECTING TO COURT: " + str(courtID) + "****"
        print 'Generic Exception: ' + traceback.format_exc()
    return html


def printAndLogNewDoc(VERBOSITY, ct, cite):
    '''
    Simply prints the log message and then logs it.
    '''
    caseName = smart_unicode(str(cite), errors='ignore')
    if (cite.westCite != '') and (cite.westCite != None):
        caseNum = cite.westCite
    elif (cite.lexisCite != '') and (cite.lexisCite != None):
        caseNum = cite.lexisCite
    elif (cite.docketNumber != '') and (cite.docketNumber != None):
        caseNum = cite.docketNumber

    if VERBOSITY >= 1:
        print time.strftime("%a, %d %b %Y %H:%M", time.localtime()) + \
            ": Added " + ct.citation_string + ": " + caseName + \
            ", " + str(caseNum)
    logger.debug(time.strftime("%a, %d %b %Y %H:%M", time.localtime()) +
        ": Added " + ct.citation_string + ": " + caseName + \
        ", " + str(caseNum))


def court_changed(url, hash):
    '''Determines whether a court website has changed since we last saw it.
    
    Takes a hash generated by Juriscraper, and compares that hash to a value 
    in the DB, if there is one. If there is a value and it is the same, it 
    returns False. Else, it returns True.
    '''
    urlToHash, created = urlToHash.objects.get_or_create(url=url)

    if not created and url2Hash.SHA1 == hash:
        # it wasn't created, and it has the same SHA --> not changed.
        return False
    else:
        # It's a newn URL or it's a changed hash --> Thus update the db.
        # and save the changes.
        url2Hash.SHA1 = hash
        url2Hash.save()
        return True

def save_all(doc, ct, myFile, case_name, docketNumber, VERBOSITY):
    '''Runs standard finishing code on a document

    '''


    return doc
